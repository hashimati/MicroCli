package ${packageName}.utils


import java.lang.reflect.Field
import java.util.*
import java.util.stream.Collectors
import java.util.stream.IntStream
import kotlin.random.Random


/**
 *
 * @author Ahmed Al Hashmi (@hashimati)
 */


class Randomizer<T>(private val tClass: Class<T>) {
    private val rnd: Random

    @get:Throws(IllegalAccessException::class, InstantiationException::class)
    val randomInstance: T
        get() {
            val t = tClass.newInstance()
            val fields = Arrays.asList(*tClass.declaredFields)
                    .stream().filter { f: Field ->
                        (!f.name.equals("id", ignoreCase = true)
                                && !f.name.equals("datecreated", ignoreCase = true)
                                && !f.name.equals("dateupdated", ignoreCase = true))
                    }
                    .collect(Collectors.toList())
            for (f in fields) {
                f.isAccessible = true
                if (String::class.java.typeName.equals(f.type)) {
                    try {
                        val charList = IntStream.range(1, 5)
                                .boxed()
                                .map { x: Int -> x.toChar() }
                                .collect(Collectors.toList())
                        val stringBuilder = StringBuilder()
                        while (charList.size > 0) {
                            val index = rnd.nextInt(charList.size)
                            stringBuilder.append(charList[index])
                            charList.removeAt(index)
                        }
                        f[t] = stringBuilder.toString()
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (Date::class.java.typeName.equals(f.type)) {
                    try {
                        f[t] = Date()
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (Char.javaClass.typeName.equals( f.type)) {
                    try {
                        f.setChar(t, rnd.nextInt(100).toChar())
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (kotlin.Byte.javaClass.typeName.equals( f.type)) {
                    try {
                        f.setByte(t, rnd.nextInt(100).toByte())
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (kotlin.Short.javaClass.typeName.equals(f.type)) {
                    try {
                        f.setShort(t, rnd.nextInt(100).toShort())
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (kotlin.Int.javaClass.typeName.equals( f.type)) {
                    try {
                        f.setInt(t, rnd.nextInt(100))
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (kotlin.Long.javaClass.typeName.equals( f.type.name)) {
                    try {
                        f.setLong(t, rnd.nextLong())
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (kotlin.Boolean.javaClass.typeName.equals( f.type.name)) {
                    try {
                        f.setBoolean(t, rnd.nextBoolean())
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (kotlin.Double.javaClass.typeName.equals( f.type.name)) {
                    try {
                        f.setDouble(t, rnd.nextDouble())
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                } else if (kotlin.Float.javaClass.typeName.equals( f.type.name)) {
                    try {
                        f.setFloat(t, rnd.nextFloat())
                    } catch (e: IllegalAccessException) {
                        e.printStackTrace()
                    }
                }
                System.gc()
            }
            return t
        }

    init {
        rnd = Random
    }
}

